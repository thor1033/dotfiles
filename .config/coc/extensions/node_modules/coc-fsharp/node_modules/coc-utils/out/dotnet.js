"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotnetResolver = void 0;
const child_process_1 = __importDefault(require("child_process"));
const which_1 = __importDefault(require("which"));
const os_1 = __importDefault(require("os"));
class DotnetResolver {
    static getDotnetExecutable() {
        return new Promise((resolve, _) => {
            which_1.default("dotnet", (err, path) => {
                if (err) {
                    resolve(undefined);
                }
                else {
                    resolve(path);
                }
            });
        });
    }
    static getDotnetInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const dotnet = yield DotnetResolver.getDotnetExecutable();
            const p = child_process_1.default.spawnSync(dotnet, ["--info"]);
            const out = p.stdout.toString().split(os_1.default.EOL);
            let info = {
                sdkVersion: '', sdkCommit: '',
                osName: '', osVersion: '', osPlatform: '', RID: '', basePath: '',
                hostVersion: '', hostCommit: '',
                sdksInstalled: [], runtimesInstalled: [],
            };
            const sp = (s, sep) => {
                for (var i = 0; i < s.length; ++i) {
                    if (s[i] === sep) {
                        return [s.substr(0, i), s.substr(i + 1)];
                    }
                }
                return [s];
            };
            const kv = (s, pat, f) => {
                let [k, v] = sp(s.trim(), ':');
                if (k === pat) {
                    let data = {};
                    data[f] = v.trim();
                    info = Object.assign(info, data);
                }
            };
            const detup = (s) => {
                let [x, path] = sp(s, '[');
                path = path.substr(0, path.length - 1);
                return { t: x.trim().split(' '), p: path };
            };
            const parse = {
                'ver': (s) => {
                    kv(s, 'Version', 'sdkVersion');
                    kv(s, 'Commit', 'sdkCommit');
                },
                'env': (s) => {
                    kv(s, 'OS Name', 'osName');
                    kv(s, 'OS Version', 'osVersion');
                    kv(s, 'OS Platform', 'osPlatform');
                    kv(s, 'RID', 'RID');
                    kv(s, 'Base Path', 'basePath');
                },
                'host': (s) => {
                    kv(s, 'Version', 'hostVersion');
                    kv(s, 'Commit', 'hostCommit');
                },
                'sdks': (s) => {
                    let { t: [v], p: p } = detup(s);
                    info.sdksInstalled.push({ version: v, path: p });
                },
                'rt': (s) => {
                    let { t: [n, v], p: p } = detup(s);
                    info.runtimesInstalled.push({ version: v, name: n, path: p });
                },
                '': (_) => { },
            };
            let state = '';
            for (let s of out) {
                console.log(s);
                switch (s) {
                    case '.NET SDK (reflecting any global.json):':
                    case '.NET Core SDK (reflecting any global.json):':
                        state = 'ver';
                        break;
                    case 'Runtime Environment:':
                        state = 'env';
                        break;
                    case 'Host (useful for support):':
                        state = 'host';
                        break;
                    case '.NET SDKs installed:':
                    case '.NET Core SDKs installed:':
                        state = 'sdks';
                        break;
                    case '.NET runtimes installed:':
                    case '.NET Core runtimes installed:':
                        state = 'rt';
                        break;
                    case '':
                        state = '';
                        break;
                    default:
                        parse[state](s);
                        break;
                }
            }
            return info;
        });
    }
}
exports.DotnetResolver = DotnetResolver;
//# sourceMappingURL=dotnet.js.map