'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const coc_utils_1 = require("coc-utils");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const path_1 = __importDefault(require("path"));
const fsac_pkgs = {
    "win-x64": {
        executable: "fsautocomplete.dll",
        platformPath: "fsautocomplete.netcore.zip"
    },
    "linux-x64": {
        executable: "fsautocomplete.dll",
        platformPath: "fsautocomplete.netcore.zip"
    },
    "osx-x64": {
        executable: "fsautocomplete.dll",
        platformPath: "fsautocomplete.netcore.zip"
    },
    "linux-arm64": {
        executable: "fsautocomplete.dll",
        platformPath: "fsautocomplete.netcore.zip"
    },
};
const fsac_repo = {
    kind: "github",
    repo: "fsharp/FsAutoComplete",
    channel: "latest"
};
class FSAC {
    static f1help() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!FSAC.client.started) {
                return null;
            }
            let cursor = yield coc_nvim_1.workspace.getCursorPosition();
            let doc = yield coc_nvim_1.workspace.document;
            let id = vscode_languageserver_protocol_1.TextDocumentIdentifier.create(doc.uri);
            let uri = yield FSAC.client.sendRequest('fsharp/f1Help', {
                textDocument: id,
                position: cursor
            });
            return JSON.parse(uri.content).Data;
        });
    }
    static activate(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // The server is packaged as a .NET core assembly
            const lsprovider = new coc_utils_1.LanguageServerProvider(context, "FSAC server", fsac_pkgs, fsac_repo);
            const languageServerExe = yield lsprovider.getLanguageServer();
            const config = coc_nvim_1.workspace.getConfiguration('FSharp');
            let serverArgs = [languageServerExe, "--background-service-enabled"];
            if (config.get("server.trace")) {
                serverArgs.push("--verbose");
                context.logger.info("coc-fsharp: activating verbose logging");
            }
            let dotnet = yield coc_utils_1.DotnetResolver.getDotnetInfo();
            let dotnetRoot = path_1.default.join(dotnet.sdksInstalled[0].path, '..');
            let env = Object.assign(process.env, { DOTNET_ROOT: dotnetRoot });
            let serverOptions = {
                command: "dotnet",
                args: serverArgs,
                options: { env: env, cwd: coc_nvim_1.workspace.cwd },
                transport: coc_nvim_1.TransportKind.stdio
            };
            let server_outputchannel = coc_nvim_1.workspace.createOutputChannel("FSAC");
            // Options to control the language client
            let clientOptions = {
                // Register the server for F# documents
                documentSelector: [{ scheme: 'file', language: 'fsharp' }],
                synchronize: {
                    // Synchronize the setting section 'FSharp' to the server
                    configurationSection: 'FSharp',
                    // Notify the server about file changes to F# project files contain in the workspace
                    fileEvents: [
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsproj'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fs'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsi'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsx'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/project.assets.json')
                    ],
                },
                initializationOptions: {
                    // setting it to true will start Workspace Loading without need to run fsharp/workspacePeek and fsharp/workspaceLoad commands. 
                    // It will always choose top workspace from the found list - all projects in workspace if 0 .sln files are found, .sln file 
                    // if 1 .sln file was found, .sln file with most projects if multiple .sln files were found. It's designed to be used in clients 
                    // that doesn't allow to create custom UI for selecting workspaces.
                    AutomaticWorkspaceInit: true
                },
                outputChannel: server_outputchannel
            };
            // Create the language client and start the client.
            FSAC.client = new coc_nvim_1.LanguageClient('fsharp', 'FsAutoComplete Language Server', serverOptions, clientOptions);
            FSAC.clientDisposable = FSAC.client.start();
            // Push the disposable to the context's subscriptions so that the 
            // client can be deactivated on extension deactivation
            context.subscriptions.push(FSAC.clientDisposable);
            context.subscriptions.push(coc_nvim_1.commands.registerCommand('fsharp.downloadLanguageServer', () => __awaiter(this, void 0, void 0, function* () {
                if (FSAC.client.started) {
                    yield FSAC.client.stop();
                    FSAC.clientDisposable.dispose();
                    yield coc_utils_1.sleep(1000);
                }
                yield lsprovider.downloadLanguageServer();
                FSAC.clientDisposable = FSAC.client.start();
                context.subscriptions.push(FSAC.clientDisposable);
            })));
        });
    }
}
exports.default = FSAC;
//# sourceMappingURL=fsac.js.map